{"ast":null,"code":"var _jsxFileName = \"/Users/Pravin/Study/nikhil/react/sample-app-web/src/components/Conference.jsx\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { notification } from 'antd';\nimport React from 'react';\nimport { AppContext } from '../stores/AppContext';\nimport { Gallery } from './Conference/gallery';\nimport { Pinned } from './Conference/pinned';\nimport { Controls } from './Controls'; // import PeerState, { onRoomStateChange } from '../utils/state';\n\nconst modes = {\n  GALLERY: 'GALLERY',\n  PINNED: 'PINNED'\n};\n\nclass Conference extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"componentDidMount\", () => {\n      const {\n        client\n      } = this.props;\n      client.on('stream-add', this._handleAddStream);\n      client.on('stream-remove', this._handleRemoveStream);\n    });\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      const {\n        client\n      } = this.props;\n\n      if (client) {\n        client.off('stream-add', this._handleAddStream);\n        client.off('stream-remove', this._handleRemoveStream);\n      }\n    });\n\n    _defineProperty(this, \"cleanUp\", async () => {\n      let {\n        localStream,\n        localScreen,\n        streams\n      } = this.state;\n      await this.setState({\n        localStream: null,\n        localScreen: null,\n        streams: []\n      });\n      await this._unpublish(localStream);\n      await this._unpublish(localScreen);\n    });\n\n    _defineProperty(this, \"_notification\", (message, description) => {\n      notification.info({\n        message: message,\n        description: description,\n        placement: 'bottomRight'\n      });\n    });\n\n    _defineProperty(this, \"_unpublish\", async stream => {\n      const {\n        client\n      } = this.props;\n\n      if (stream) {\n        await this._stopMediaStream(stream);\n        await client.unpublish(stream, client.rid);\n      }\n    });\n\n    _defineProperty(this, \"muteMediaTrack\", (type, enabled) => {\n      let {\n        localStream\n      } = this.state;\n\n      if (!localStream) {\n        return;\n      }\n\n      if (enabled) {\n        localStream.unmute(type);\n      } else {\n        localStream.mute(type);\n      }\n\n      if (type === 'audio') {\n        this.setState({\n          audioMuted: !enabled\n        }); // this.peerState && this.peerState.update({ audioEnabled: enabled });\n      } else if (type === 'video') {\n        this.setState({\n          videoMuted: !enabled\n        }); // this.peerState && this.peerState.update({ videoEnabled: enabled });\n      }\n    });\n\n    _defineProperty(this, \"handleLocalStream\", async () => {\n      let {\n        localStream\n      } = this.state;\n      const {\n        client,\n        settings,\n        localVideoEnabled,\n        localAudioEnabled\n      } = this.props;\n      console.log('SETTINGS:', settings);\n      client.getLocalStream({\n        codec: settings.codec.toUpperCase(),\n        resolution: settings.resolution,\n        bitrate: settings.bandwidth,\n        frameRate: settings.frameRate,\n        shouldPublishAudio: localAudioEnabled,\n        shouldPublishVideo: localVideoEnabled,\n        advancedMediaConstraints: {\n          video: {\n            deviceId: settings.selectedVideoDevice\n          },\n          audio: {\n            deviceId: settings.selectedAudioDevice\n          }\n        }\n      }).then(localStream => {\n        return client.publish(localStream, client.rid);\n      }).then(localStream => {\n        this.setState({\n          localStream\n        });\n        !localAudioEnabled && this.muteMediaTrack('audio', this.state.audioMuted);\n        !localVideoEnabled && this.muteMediaTrack('video', this.state.videoMuted);\n      }).catch(error => {\n        this.props.setLocalStreamError(error);\n      });\n    });\n\n    _defineProperty(this, \"handleScreenSharing\", async enabled => {\n      let {\n        localScreen\n      } = this.state;\n      const {\n        client,\n        settings\n      } = this.props;\n\n      if (enabled) {\n        localScreen = await client.getLocalScreen({\n          bitrate: 0,\n          codec: settings.codec.toUpperCase(),\n          frameRate: 10\n        });\n        localScreen.getVideoTracks().forEach(track => {\n          if ('contentHint' in track) {\n            track.contentHint = 'text';\n          }\n        });\n        console.log({\n          localScreen\n        });\n        await client.publish(localScreen, client.rid);\n        let track = localScreen.getVideoTracks()[0];\n\n        if (track) {\n          track.addEventListener('ended', () => {\n            this.handleScreenSharing(false);\n          });\n        }\n      } else {\n        if (localScreen) {\n          this._unpublish(localScreen);\n\n          localScreen = null;\n\n          if (this.state.mode === modes.PINNED && this.state.pinned === client.uid + '-screen') {\n            this.setState({\n              mode: modes.GALLERY\n            });\n          }\n        }\n      }\n\n      this.setState({\n        localScreen\n      });\n    });\n\n    _defineProperty(this, \"_stopMediaStream\", async stream => {\n      let tracks = stream.getTracks();\n\n      for (let i = 0, len = tracks.length; i < len; i++) {\n        await tracks[i].stop();\n      }\n    });\n\n    _defineProperty(this, \"_handleAddStream\", async (room, peer, streamInfo) => {\n      const {\n        client\n      } = this.props;\n      let streams = this.state.streams;\n\n      try {\n        let stream = await client.subscribe(streamInfo.mid, room);\n        stream.info = {\n          name: peer.name\n        }; // @NOTE: Just because stream is expected to have info in this format at the moment by the UI\n\n        if (this.state.streamInfo, stream.mid) {\n          streams.push(_objectSpread({\n            mid: stream.mid,\n            stream,\n            sid: streamInfo.mid\n          }, this.state.streamInfo[stream.mid]));\n        } else {\n          streams.push({\n            mid: stream.mid,\n            stream,\n            sid: streamInfo.mid\n          });\n        }\n\n        this.setState({\n          streams\n        });\n      } catch (error) {\n        this._notification(`ERROR: Error in subscribing`, error.message);\n\n        this.props.cleanUp();\n      }\n    });\n\n    _defineProperty(this, \"_handleRemoveStream\", async (room, peer, streamInfo) => {\n      // `room` might be used later in future\n      let streams = this.state.streams;\n      streams = streams.filter(item => item.sid !== streamInfo.mid);\n      this.setState({\n        streams\n      });\n\n      if (this.state.mode === modes.PINNED && this.state.pinned === streamInfo.mid) {\n        this.setState({\n          mode: modes.GALLERY\n        });\n      }\n    });\n\n    _defineProperty(this, \"_onRequest\", (uid, request) => {// this.peerState && this.peerState.setRequest(uid, request);\n    });\n\n    _defineProperty(this, \"_onChangeVideoPosition\", data => {\n      let id = data.id;\n      let index = data.index;\n      console.log('_onChangeVideoPosition id:' + id + '  index:' + index);\n\n      if (index == 0) {\n        return;\n      }\n\n      const streams = this.state.streams;\n      let first = 0;\n      let big = 0;\n\n      for (let i = 0; i < streams.length; i++) {\n        let item = streams[i];\n\n        if (item.mid == id) {\n          big = i;\n          break;\n        }\n      }\n\n      let c = streams[first];\n      streams[first] = streams[big];\n      streams[big] = c;\n      this.setState({\n        streams: streams\n      });\n    });\n\n    _defineProperty(this, \"render\", () => {\n      const {\n        client,\n        role\n      } = this.props;\n      const {\n        streams,\n        localStream,\n        localScreen,\n        audioMuted,\n        videoMuted\n      } = this.state;\n      const id = client ? client.uid : null;\n      let videoCount = streams.length;\n      if (localStream) videoCount++;\n      if (localScreen) videoCount++;\n      if (client) return __jsx(React.Fragment, null, this.state.mode === modes.PINNED ? __jsx(Pinned, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: this.props.loginInfo,\n        pinned: this.state.pinned,\n        onUnpin: () => {\n          this.setState({\n            mode: modes.GALLERY\n          });\n        },\n        onRequest: this._onRequest,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 265,\n          columnNumber: 13\n        }\n      }) : __jsx(Gallery, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: this.props.loginInfo,\n        onPin: streamId => {\n          this.setState({\n            mode: modes.PINNED,\n            pinned: streamId\n          });\n        },\n        onRequest: this._onRequest,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 284,\n          columnNumber: 13\n        }\n      }), __jsx(AppContext.Consumer, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 303,\n          columnNumber: 11\n        }\n      }, context => __jsx(Controls, {\n        role: role,\n        isMuted: this.state.audioMuted,\n        isCameraOn: !this.state.videoMuted,\n        screenSharingEnabled: context.roomState.screenSharingEnabled,\n        onScreenToggle: this.props.onScreenToggle,\n        onLeave: this.props.onLeave,\n        onMicToggle: () => {\n          this.muteMediaTrack('audio', this.state.audioMuted);\n        },\n        onCamToggle: () => {\n          this.muteMediaTrack('video', this.state.videoMuted);\n        },\n        onChatToggle: this.props.onChatToggle,\n        isChatOpen: this.props.isChatOpen,\n        loginInfo: this.props.loginInfo,\n        hasUnreadMessages: this.props.hasUnreadMessages,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 305,\n          columnNumber: 15\n        }\n      })));\n      return __jsx(React.Fragment, null);\n    });\n\n    this.state = {\n      streams: [],\n      streamInfo: [],\n      localStream: null,\n      localScreen: null,\n      audioMuted: false,\n      videoMuted: false,\n      mode: modes.GALLERY,\n      pinned: false,\n      localStreamError: null\n    };\n  }\n\n}\n\nexport default Conference;","map":{"version":3,"sources":["/Users/Pravin/Study/nikhil/react/sample-app-web/src/components/Conference.jsx"],"names":["notification","React","AppContext","Gallery","Pinned","Controls","modes","GALLERY","PINNED","Conference","Component","constructor","props","client","on","_handleAddStream","_handleRemoveStream","off","localStream","localScreen","streams","state","setState","_unpublish","message","description","info","placement","stream","_stopMediaStream","unpublish","rid","type","enabled","unmute","mute","audioMuted","videoMuted","settings","localVideoEnabled","localAudioEnabled","console","log","getLocalStream","codec","toUpperCase","resolution","bitrate","bandwidth","frameRate","shouldPublishAudio","shouldPublishVideo","advancedMediaConstraints","video","deviceId","selectedVideoDevice","audio","selectedAudioDevice","then","publish","muteMediaTrack","catch","error","setLocalStreamError","getLocalScreen","getVideoTracks","forEach","track","contentHint","addEventListener","handleScreenSharing","mode","pinned","uid","tracks","getTracks","i","len","length","stop","room","peer","streamInfo","subscribe","mid","name","push","sid","_notification","cleanUp","filter","item","request","data","id","index","first","big","c","role","videoCount","loginInfo","_onRequest","streamId","context","roomState","screenSharingEnabled","onScreenToggle","onLeave","onChatToggle","isChatOpen","hasUnreadMessages","localStreamError"],"mappings":"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","sourcesContent":["import { notification } from 'antd';\nimport React from 'react';\nimport { AppContext } from '../stores/AppContext';\nimport { Gallery } from './Conference/gallery';\nimport { Pinned } from './Conference/pinned';\nimport { Controls } from './Controls';\n// import PeerState, { onRoomStateChange } from '../utils/state';\n\nconst modes = {\n  GALLERY: 'GALLERY',\n  PINNED: 'PINNED',\n};\n\nclass Conference extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      streams: [],\n      streamInfo: [],\n      localStream: null,\n      localScreen: null,\n      audioMuted: false,\n      videoMuted: false,\n      mode: modes.GALLERY,\n      pinned: false,\n      localStreamError: null,\n    };\n  }\n\n  componentDidMount = () => {\n    const { client } = this.props;\n    client.on('stream-add', this._handleAddStream);\n    client.on('stream-remove', this._handleRemoveStream);\n  };\n\n  componentWillUnmount = () => {\n    const { client } = this.props;\n    if (client) {\n      client.off('stream-add', this._handleAddStream);\n      client.off('stream-remove', this._handleRemoveStream);\n    }\n  };\n\n  cleanUp = async () => {\n    let { localStream, localScreen, streams } = this.state;\n    await this.setState({ localStream: null, localScreen: null, streams: [] });\n\n    await this._unpublish(localStream);\n    await this._unpublish(localScreen);\n  };\n\n  _notification = (message, description) => {\n    notification.info({\n      message: message,\n      description: description,\n      placement: 'bottomRight',\n    });\n  };\n\n  _unpublish = async stream => {\n    const { client } = this.props;\n    if (stream) {\n      await this._stopMediaStream(stream);\n      await client.unpublish(stream, client.rid);\n    }\n  };\n\n  muteMediaTrack = (type, enabled) => {\n    let { localStream } = this.state;\n    if (!localStream) {\n      return;\n    }\n    if (enabled) {\n      localStream.unmute(type);\n    } else {\n      localStream.mute(type);\n    }\n\n    if (type === 'audio') {\n      this.setState({ audioMuted: !enabled });\n      // this.peerState && this.peerState.update({ audioEnabled: enabled });\n    } else if (type === 'video') {\n      this.setState({ videoMuted: !enabled });\n      // this.peerState && this.peerState.update({ videoEnabled: enabled });\n    }\n  };\n\n  handleLocalStream = async () => {\n    let { localStream } = this.state;\n    const {\n      client,\n      settings,\n      localVideoEnabled,\n      localAudioEnabled,\n    } = this.props;\n\n    console.log('SETTINGS:', settings);\n\n    client\n      .getLocalStream({\n        codec: settings.codec.toUpperCase(),\n        resolution: settings.resolution,\n        bitrate: settings.bandwidth,\n        frameRate: settings.frameRate,\n        shouldPublishAudio: localAudioEnabled,\n        shouldPublishVideo: localVideoEnabled,\n        advancedMediaConstraints: {\n          video: {\n            deviceId: settings.selectedVideoDevice,\n          },\n          audio: {\n            deviceId: settings.selectedAudioDevice,\n          },\n        },\n      })\n      .then(localStream => {\n        return client.publish(localStream, client.rid);\n      })\n      .then(localStream => {\n        this.setState({ localStream });\n        !localAudioEnabled &&\n          this.muteMediaTrack('audio', this.state.audioMuted);\n        !localVideoEnabled &&\n          this.muteMediaTrack('video', this.state.videoMuted);\n      })\n      .catch(error => {\n        this.props.setLocalStreamError(error);\n      });\n  };\n\n  handleScreenSharing = async enabled => {\n    let { localScreen } = this.state;\n    const { client, settings } = this.props;\n    if (enabled) {\n      localScreen = await client.getLocalScreen({\n        bitrate: 0,\n        codec: settings.codec.toUpperCase(),\n        frameRate: 10,\n      });\n      localScreen.getVideoTracks().forEach(track => {\n        if ('contentHint' in track) {\n          track.contentHint = 'text';\n        }\n      });\n      console.log({ localScreen });\n      await client.publish(localScreen, client.rid);\n      let track = localScreen.getVideoTracks()[0];\n      if (track) {\n        track.addEventListener('ended', () => {\n          this.handleScreenSharing(false);\n        });\n      }\n    } else {\n      if (localScreen) {\n        this._unpublish(localScreen);\n        localScreen = null;\n        if (\n          this.state.mode === modes.PINNED &&\n          this.state.pinned === client.uid + '-screen'\n        ) {\n          this.setState({\n            mode: modes.GALLERY,\n          });\n        }\n      }\n    }\n    this.setState({ localScreen });\n  };\n\n  _stopMediaStream = async stream => {\n    let tracks = stream.getTracks();\n    for (let i = 0, len = tracks.length; i < len; i++) {\n      await tracks[i].stop();\n    }\n  };\n\n  _handleAddStream = async (room, peer, streamInfo) => {\n    const { client } = this.props;\n    let streams = this.state.streams;\n    try {\n      let stream = await client.subscribe(streamInfo.mid, room);\n      stream.info = { name: peer.name }; // @NOTE: Just because stream is expected to have info in this format at the moment by the UI\n      if ((this.state.streamInfo, stream.mid)) {\n        streams.push({\n          mid: stream.mid,\n          stream,\n          sid: streamInfo.mid,\n          ...this.state.streamInfo[stream.mid],\n        });\n      } else {\n        streams.push({ mid: stream.mid, stream, sid: streamInfo.mid });\n      }\n\n      this.setState({ streams });\n    } catch (error) {\n      this._notification(`ERROR: Error in subscribing`, error.message);\n      this.props.cleanUp();\n    }\n  };\n\n  _handleRemoveStream = async (room, peer, streamInfo) => {\n    // `room` might be used later in future\n    let streams = this.state.streams;\n    streams = streams.filter(item => item.sid !== streamInfo.mid);\n    this.setState({ streams });\n    if (\n      this.state.mode === modes.PINNED &&\n      this.state.pinned === streamInfo.mid\n    ) {\n      this.setState({\n        mode: modes.GALLERY,\n      });\n    }\n  };\n\n  _onRequest = (uid, request) => {\n    // this.peerState && this.peerState.setRequest(uid, request);\n  };\n\n  _onChangeVideoPosition = data => {\n    let id = data.id;\n    let index = data.index;\n    console.log('_onChangeVideoPosition id:' + id + '  index:' + index);\n\n    if (index == 0) {\n      return;\n    }\n\n    const streams = this.state.streams;\n    let first = 0;\n    let big = 0;\n    for (let i = 0; i < streams.length; i++) {\n      let item = streams[i];\n      if (item.mid == id) {\n        big = i;\n        break;\n      }\n    }\n\n    let c = streams[first];\n    streams[first] = streams[big];\n    streams[big] = c;\n\n    this.setState({ streams: streams });\n  };\n\n  render = () => {\n    const { client, role } = this.props;\n    const {\n      streams,\n      localStream,\n      localScreen,\n      audioMuted,\n      videoMuted,\n    } = this.state;\n    const id = client ? client.uid : null;\n    let videoCount = streams.length;\n    if (localStream) videoCount++;\n    if (localScreen) videoCount++;\n\n    if (client)\n      return (\n        <>\n          {this.state.mode === modes.PINNED ? (\n            <Pinned\n              streams={streams}\n              audioMuted={audioMuted}\n              videoMuted={videoMuted}\n              videoCount={videoCount}\n              localStream={localStream}\n              localScreen={localScreen}\n              client={client}\n              id={id}\n              loginInfo={this.props.loginInfo}\n              pinned={this.state.pinned}\n              onUnpin={() => {\n                this.setState({\n                  mode: modes.GALLERY,\n                });\n              }}\n              onRequest={this._onRequest}\n            />\n          ) : (\n            <Gallery\n              streams={streams}\n              audioMuted={audioMuted}\n              videoMuted={videoMuted}\n              videoCount={videoCount}\n              localStream={localStream}\n              localScreen={localScreen}\n              client={client}\n              id={id}\n              loginInfo={this.props.loginInfo}\n              onPin={streamId => {\n                this.setState({\n                  mode: modes.PINNED,\n                  pinned: streamId,\n                });\n              }}\n              onRequest={this._onRequest}\n            />\n          )}\n          <AppContext.Consumer>\n            {context => (\n              <Controls\n                role={role}\n                isMuted={this.state.audioMuted}\n                isCameraOn={!this.state.videoMuted}\n                screenSharingEnabled={context.roomState.screenSharingEnabled}\n                onScreenToggle={this.props.onScreenToggle}\n                onLeave={this.props.onLeave}\n                onMicToggle={() => {\n                  this.muteMediaTrack('audio', this.state.audioMuted);\n                }}\n                onCamToggle={() => {\n                  this.muteMediaTrack('video', this.state.videoMuted);\n                }}\n                onChatToggle={this.props.onChatToggle}\n                isChatOpen={this.props.isChatOpen}\n                loginInfo={this.props.loginInfo}\n                hasUnreadMessages={this.props.hasUnreadMessages}\n              />\n            )}\n          </AppContext.Consumer>\n        </>\n      );\n    return <></>;\n  };\n}\nexport default Conference;\n"]},"metadata":{},"sourceType":"module"}