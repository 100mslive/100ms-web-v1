{"ast":null,"code":"import _regeneratorRuntime from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"/Users/Pravin/Study/nikhil/react/sample-app-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { notification } from 'antd';\nimport React from 'react';\nimport { AppContext } from '../stores/AppContext';\nimport { Gallery } from './Conference/gallery';\nimport { Pinned } from './Conference/pinned';\nimport { Controls } from './Controls'; // import PeerState, { onRoomStateChange } from '../utils/state';\n\nvar modes = {\n  GALLERY: 'GALLERY',\n  PINNED: 'PINNED'\n};\n\nvar Conference = /*#__PURE__*/function (_React$Component) {\n  _inherits(Conference, _React$Component);\n\n  var _super = _createSuper(Conference);\n\n  function Conference(props) {\n    var _this;\n\n    _classCallCheck(this, Conference);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      var client = _this.props.client;\n      client.on('stream-add', _this._handleAddStream);\n      client.on('stream-remove', _this._handleRemoveStream);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function () {\n      var client = _this.props.client;\n\n      if (client) {\n        client.off('stream-add', _this._handleAddStream);\n        client.off('stream-remove', _this._handleRemoveStream);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"cleanUp\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _this$state, localStream, localScreen, streams;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$state = _this.state, localStream = _this$state.localStream, localScreen = _this$state.localScreen, streams = _this$state.streams;\n              _context.next = 3;\n              return _this.setState({\n                localStream: null,\n                localScreen: null,\n                streams: []\n              });\n\n            case 3:\n              _context.next = 5;\n              return _this._unpublish(localStream);\n\n            case 5:\n              _context.next = 7;\n              return _this._unpublish(localScreen);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"_notification\", function (message, description) {\n      notification.info({\n        message: message,\n        description: description,\n        placement: 'bottomRight'\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_unpublish\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(stream) {\n        var client;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                client = _this.props.client;\n\n                if (!stream) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                _context2.next = 4;\n                return _this._stopMediaStream(stream);\n\n              case 4:\n                _context2.next = 6;\n                return client.unpublish(stream, client.rid);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"muteMediaTrack\", function (type, enabled) {\n      var localStream = _this.state.localStream;\n\n      if (!localStream) {\n        return;\n      }\n\n      if (enabled) {\n        localStream.unmute(type);\n      } else {\n        localStream.mute(type);\n      }\n\n      if (type === 'audio') {\n        _this.setState({\n          audioMuted: !enabled\n        }); // this.peerState && this.peerState.update({ audioEnabled: enabled });\n\n      } else if (type === 'video') {\n        _this.setState({\n          videoMuted: !enabled\n        }); // this.peerState && this.peerState.update({ videoEnabled: enabled });\n\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleLocalStream\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var localStream, _this$props, client, settings, localVideoEnabled, localAudioEnabled;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              localStream = _this.state.localStream;\n              _this$props = _this.props, client = _this$props.client, settings = _this$props.settings, localVideoEnabled = _this$props.localVideoEnabled, localAudioEnabled = _this$props.localAudioEnabled;\n              console.log('SETTINGS:', settings);\n              client.getLocalStream({\n                codec: settings.codec.toUpperCase(),\n                resolution: settings.resolution,\n                bitrate: settings.bandwidth,\n                frameRate: settings.frameRate,\n                shouldPublishAudio: localAudioEnabled,\n                shouldPublishVideo: localVideoEnabled,\n                advancedMediaConstraints: {\n                  video: {\n                    deviceId: settings.selectedVideoDevice\n                  },\n                  audio: {\n                    deviceId: settings.selectedAudioDevice\n                  }\n                }\n              }).then(function (localStream) {\n                return client.publish(localStream, client.rid);\n              }).then(function (localStream) {\n                _this.setState({\n                  localStream: localStream\n                });\n\n                !localAudioEnabled && _this.muteMediaTrack('audio', _this.state.audioMuted);\n                !localVideoEnabled && _this.muteMediaTrack('video', _this.state.videoMuted);\n              })[\"catch\"](function (error) {\n                _this.props.setLocalStreamError(error);\n              });\n\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"handleScreenSharing\", /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(enabled) {\n        var localScreen, _this$props2, client, settings, track;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                localScreen = _this.state.localScreen;\n                _this$props2 = _this.props, client = _this$props2.client, settings = _this$props2.settings;\n\n                if (!enabled) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                _context4.next = 5;\n                return client.getLocalScreen({\n                  bitrate: 0,\n                  codec: settings.codec.toUpperCase(),\n                  frameRate: 10\n                });\n\n              case 5:\n                localScreen = _context4.sent;\n                localScreen.getVideoTracks().forEach(function (track) {\n                  if ('contentHint' in track) {\n                    track.contentHint = 'text';\n                  }\n                });\n                console.log({\n                  localScreen: localScreen\n                });\n                _context4.next = 10;\n                return client.publish(localScreen, client.rid);\n\n              case 10:\n                track = localScreen.getVideoTracks()[0];\n\n                if (track) {\n                  track.addEventListener('ended', function () {\n                    _this.handleScreenSharing(false);\n                  });\n                }\n\n                _context4.next = 15;\n                break;\n\n              case 14:\n                if (localScreen) {\n                  _this._unpublish(localScreen);\n\n                  localScreen = null;\n\n                  if (_this.state.mode === modes.PINNED && _this.state.pinned === client.uid + '-screen') {\n                    _this.setState({\n                      mode: modes.GALLERY\n                    });\n                  }\n                }\n\n              case 15:\n                _this.setState({\n                  localScreen: localScreen\n                });\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x2) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"_stopMediaStream\", /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(stream) {\n        var tracks, i, len;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                tracks = stream.getTracks();\n                i = 0, len = tracks.length;\n\n              case 2:\n                if (!(i < len)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                _context5.next = 5;\n                return tracks[i].stop();\n\n              case 5:\n                i++;\n                _context5.next = 2;\n                break;\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      return function (_x3) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"_handleAddStream\", /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(room, peer, streamInfo) {\n        var client, streams, stream;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                client = _this.props.client;\n                streams = _this.state.streams;\n                _context6.prev = 2;\n                _context6.next = 5;\n                return client.subscribe(streamInfo.mid, room);\n\n              case 5:\n                stream = _context6.sent;\n                stream.info = {\n                  name: peer.name\n                }; // @NOTE: Just because stream is expected to have info in this format at the moment by the UI\n\n                if (_this.state.streamInfo, stream.mid) {\n                  streams.push(_objectSpread({\n                    mid: stream.mid,\n                    stream: stream,\n                    sid: streamInfo.mid\n                  }, _this.state.streamInfo[stream.mid]));\n                } else {\n                  streams.push({\n                    mid: stream.mid,\n                    stream: stream,\n                    sid: streamInfo.mid\n                  });\n                }\n\n                _this.setState({\n                  streams: streams\n                });\n\n                _context6.next = 15;\n                break;\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](2);\n\n                _this._notification(\"ERROR: Error in subscribing\", _context6.t0.message);\n\n                _this.props.cleanUp();\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[2, 11]]);\n      }));\n\n      return function (_x4, _x5, _x6) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"_handleRemoveStream\", /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(room, peer, streamInfo) {\n        var streams;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // `room` might be used later in future\n                streams = _this.state.streams;\n                streams = streams.filter(function (item) {\n                  return item.sid !== streamInfo.mid;\n                });\n\n                _this.setState({\n                  streams: streams\n                });\n\n                if (_this.state.mode === modes.PINNED && _this.state.pinned === streamInfo.mid) {\n                  _this.setState({\n                    mode: modes.GALLERY\n                  });\n                }\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      return function (_x7, _x8, _x9) {\n        return _ref7.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onRequest\", function (uid, request) {// this.peerState && this.peerState.setRequest(uid, request);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onChangeVideoPosition\", function (data) {\n      var id = data.id;\n      var index = data.index;\n      console.log('_onChangeVideoPosition id:' + id + '  index:' + index);\n\n      if (index == 0) {\n        return;\n      }\n\n      var streams = _this.state.streams;\n      var first = 0;\n      var big = 0;\n\n      for (var i = 0; i < streams.length; i++) {\n        var item = streams[i];\n\n        if (item.mid == id) {\n          big = i;\n          break;\n        }\n      }\n\n      var c = streams[first];\n      streams[first] = streams[big];\n      streams[big] = c;\n\n      _this.setState({\n        streams: streams\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"render\", function () {\n      var _this$props3 = _this.props,\n          client = _this$props3.client,\n          role = _this$props3.role;\n      var _this$state2 = _this.state,\n          streams = _this$state2.streams,\n          localStream = _this$state2.localStream,\n          localScreen = _this$state2.localScreen,\n          audioMuted = _this$state2.audioMuted,\n          videoMuted = _this$state2.videoMuted;\n      var id = client ? client.uid : null;\n      var videoCount = streams.length;\n      if (localStream) videoCount++;\n      if (localScreen) videoCount++;\n      if (client) return __jsx(React.Fragment, null, _this.state.mode === modes.PINNED ? __jsx(Pinned, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: _this.props.loginInfo,\n        pinned: _this.state.pinned,\n        onUnpin: function onUnpin() {\n          _this.setState({\n            mode: modes.GALLERY\n          });\n        },\n        onRequest: _this._onRequest\n      }) : __jsx(Gallery, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: _this.props.loginInfo,\n        onPin: function onPin(streamId) {\n          _this.setState({\n            mode: modes.PINNED,\n            pinned: streamId\n          });\n        },\n        onRequest: _this._onRequest\n      }), __jsx(AppContext.Consumer, null, function (context) {\n        return __jsx(Controls, {\n          role: role,\n          isMuted: _this.state.audioMuted,\n          isCameraOn: !_this.state.videoMuted,\n          screenSharingEnabled: context.roomState.screenSharingEnabled,\n          onScreenToggle: _this.props.onScreenToggle,\n          onLeave: _this.props.onLeave,\n          onMicToggle: function onMicToggle() {\n            _this.muteMediaTrack('audio', _this.state.audioMuted);\n          },\n          onCamToggle: function onCamToggle() {\n            _this.muteMediaTrack('video', _this.state.videoMuted);\n          },\n          onChatToggle: _this.props.onChatToggle,\n          isChatOpen: _this.props.isChatOpen,\n          loginInfo: _this.props.loginInfo,\n          hasUnreadMessages: _this.props.hasUnreadMessages\n        });\n      }));\n      return __jsx(React.Fragment, null);\n    });\n\n    _this.state = {\n      streams: [],\n      streamInfo: [],\n      localStream: null,\n      localScreen: null,\n      audioMuted: false,\n      videoMuted: false,\n      mode: modes.GALLERY,\n      pinned: false,\n      localStreamError: null\n    };\n    return _this;\n  }\n\n  return Conference;\n}(React.Component);\n\nexport default Conference;","map":null,"metadata":{},"sourceType":"module"}