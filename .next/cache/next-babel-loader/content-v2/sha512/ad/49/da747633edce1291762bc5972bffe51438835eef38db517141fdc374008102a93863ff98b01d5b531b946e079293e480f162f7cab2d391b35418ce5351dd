{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { notification } from 'antd';\nimport React from 'react';\nimport { AppContext } from '../stores/AppContext';\nimport { Gallery } from './Conference/gallery';\nimport { Pinned } from './Conference/pinned';\nimport { Controls } from './Controls'; // import PeerState, { onRoomStateChange } from '../utils/state';\n\nconst modes = {\n  GALLERY: 'GALLERY',\n  PINNED: 'PINNED'\n};\n\nclass Conference extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"componentDidMount\", () => {\n      const {\n        client\n      } = this.props;\n      client.on('stream-add', this._handleAddStream);\n      client.on('stream-remove', this._handleRemoveStream);\n    });\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      const {\n        client\n      } = this.props;\n\n      if (client) {\n        client.off('stream-add', this._handleAddStream);\n        client.off('stream-remove', this._handleRemoveStream);\n      }\n    });\n\n    _defineProperty(this, \"cleanUp\", async () => {\n      let {\n        localStream,\n        localScreen,\n        streams\n      } = this.state;\n      await this.setState({\n        localStream: null,\n        localScreen: null,\n        streams: []\n      });\n      await this._unpublish(localStream);\n      await this._unpublish(localScreen);\n    });\n\n    _defineProperty(this, \"_notification\", (message, description) => {\n      notification.info({\n        message: message,\n        description: description,\n        placement: 'bottomRight'\n      });\n    });\n\n    _defineProperty(this, \"_unpublish\", async stream => {\n      const {\n        client\n      } = this.props;\n\n      if (stream) {\n        await this._stopMediaStream(stream);\n        await client.unpublish(stream, client.rid);\n      }\n    });\n\n    _defineProperty(this, \"muteMediaTrack\", (type, enabled) => {\n      let {\n        localStream\n      } = this.state;\n\n      if (!localStream) {\n        return;\n      }\n\n      if (enabled) {\n        localStream.unmute(type);\n      } else {\n        localStream.mute(type);\n      }\n\n      if (type === 'audio') {\n        this.setState({\n          audioMuted: !enabled\n        }); // this.peerState && this.peerState.update({ audioEnabled: enabled });\n      } else if (type === 'video') {\n        this.setState({\n          videoMuted: !enabled\n        }); // this.peerState && this.peerState.update({ videoEnabled: enabled });\n      }\n    });\n\n    _defineProperty(this, \"handleLocalStream\", async () => {\n      let {\n        localStream\n      } = this.state;\n      const {\n        client,\n        settings,\n        localVideoEnabled,\n        localAudioEnabled\n      } = this.props;\n      console.log('SETTINGS:', settings);\n      client.getLocalStream({\n        codec: settings.codec.toUpperCase(),\n        resolution: settings.resolution,\n        bitrate: settings.bandwidth,\n        frameRate: settings.frameRate,\n        shouldPublishAudio: localAudioEnabled,\n        shouldPublishVideo: localVideoEnabled,\n        advancedMediaConstraints: {\n          video: {\n            deviceId: settings.selectedVideoDevice\n          },\n          audio: {\n            deviceId: settings.selectedAudioDevice\n          }\n        }\n      }).then(localStream => {\n        return client.publish(localStream, client.rid);\n      }).then(localStream => {\n        this.setState({\n          localStream\n        });\n        !localAudioEnabled && this.muteMediaTrack('audio', this.state.audioMuted);\n        !localVideoEnabled && this.muteMediaTrack('video', this.state.videoMuted);\n      }).catch(error => {\n        this.props.setLocalStreamError(error);\n      });\n    });\n\n    _defineProperty(this, \"handleScreenSharing\", async enabled => {\n      let {\n        localScreen\n      } = this.state;\n      const {\n        client,\n        settings\n      } = this.props;\n\n      if (enabled) {\n        localScreen = await client.getLocalScreen({\n          bitrate: 0,\n          codec: settings.codec.toUpperCase(),\n          frameRate: 10\n        });\n        localScreen.getVideoTracks().forEach(track => {\n          if ('contentHint' in track) {\n            track.contentHint = 'text';\n          }\n        });\n        console.log({\n          localScreen\n        });\n        await client.publish(localScreen, client.rid);\n        let track = localScreen.getVideoTracks()[0];\n\n        if (track) {\n          track.addEventListener('ended', () => {\n            this.handleScreenSharing(false);\n          });\n        }\n      } else {\n        if (localScreen) {\n          this._unpublish(localScreen);\n\n          localScreen = null;\n\n          if (this.state.mode === modes.PINNED && this.state.pinned === client.uid + '-screen') {\n            this.setState({\n              mode: modes.GALLERY\n            });\n          }\n        }\n      }\n\n      this.setState({\n        localScreen\n      });\n    });\n\n    _defineProperty(this, \"_stopMediaStream\", async stream => {\n      let tracks = stream.getTracks();\n\n      for (let i = 0, len = tracks.length; i < len; i++) {\n        await tracks[i].stop();\n      }\n    });\n\n    _defineProperty(this, \"_handleAddStream\", async (room, peer, streamInfo) => {\n      const {\n        client\n      } = this.props;\n      let streams = this.state.streams;\n\n      try {\n        let stream = await client.subscribe(streamInfo.mid, room);\n        stream.info = {\n          name: peer.name\n        }; // @NOTE: Just because stream is expected to have info in this format at the moment by the UI\n\n        if (this.state.streamInfo, stream.mid) {\n          streams.push(_objectSpread({\n            mid: stream.mid,\n            stream,\n            sid: streamInfo.mid\n          }, this.state.streamInfo[stream.mid]));\n        } else {\n          streams.push({\n            mid: stream.mid,\n            stream,\n            sid: streamInfo.mid\n          });\n        }\n\n        this.setState({\n          streams\n        });\n      } catch (error) {\n        this._notification(`ERROR: Error in subscribing`, error.message);\n\n        this.props.cleanUp();\n      }\n    });\n\n    _defineProperty(this, \"_handleRemoveStream\", async (room, peer, streamInfo) => {\n      // `room` might be used later in future\n      let streams = this.state.streams;\n      streams = streams.filter(item => item.sid !== streamInfo.mid);\n      this.setState({\n        streams\n      });\n\n      if (this.state.mode === modes.PINNED && this.state.pinned === streamInfo.mid) {\n        this.setState({\n          mode: modes.GALLERY\n        });\n      }\n    });\n\n    _defineProperty(this, \"_onRequest\", (uid, request) => {// this.peerState && this.peerState.setRequest(uid, request);\n    });\n\n    _defineProperty(this, \"_onChangeVideoPosition\", data => {\n      let id = data.id;\n      let index = data.index;\n      console.log('_onChangeVideoPosition id:' + id + '  index:' + index);\n\n      if (index == 0) {\n        return;\n      }\n\n      const streams = this.state.streams;\n      let first = 0;\n      let big = 0;\n\n      for (let i = 0; i < streams.length; i++) {\n        let item = streams[i];\n\n        if (item.mid == id) {\n          big = i;\n          break;\n        }\n      }\n\n      let c = streams[first];\n      streams[first] = streams[big];\n      streams[big] = c;\n      this.setState({\n        streams: streams\n      });\n    });\n\n    _defineProperty(this, \"render\", () => {\n      const {\n        client,\n        role\n      } = this.props;\n      const {\n        streams,\n        localStream,\n        localScreen,\n        audioMuted,\n        videoMuted\n      } = this.state;\n      const id = client ? client.uid : null;\n      let videoCount = streams.length;\n      if (localStream) videoCount++;\n      if (localScreen) videoCount++;\n      if (client) return __jsx(React.Fragment, null, this.state.mode === modes.PINNED ? __jsx(Pinned, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: this.props.loginInfo,\n        pinned: this.state.pinned,\n        onUnpin: () => {\n          this.setState({\n            mode: modes.GALLERY\n          });\n        },\n        onRequest: this._onRequest\n      }) : __jsx(Gallery, {\n        streams: streams,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted,\n        videoCount: videoCount,\n        localStream: localStream,\n        localScreen: localScreen,\n        client: client,\n        id: id,\n        loginInfo: this.props.loginInfo,\n        onPin: streamId => {\n          this.setState({\n            mode: modes.PINNED,\n            pinned: streamId\n          });\n        },\n        onRequest: this._onRequest\n      }), __jsx(AppContext.Consumer, null, context => __jsx(Controls, {\n        role: role,\n        isMuted: this.state.audioMuted,\n        isCameraOn: !this.state.videoMuted,\n        screenSharingEnabled: context.roomState.screenSharingEnabled,\n        onScreenToggle: this.props.onScreenToggle,\n        onLeave: this.props.onLeave,\n        onMicToggle: () => {\n          this.muteMediaTrack('audio', this.state.audioMuted);\n        },\n        onCamToggle: () => {\n          this.muteMediaTrack('video', this.state.videoMuted);\n        },\n        onChatToggle: this.props.onChatToggle,\n        isChatOpen: this.props.isChatOpen,\n        loginInfo: this.props.loginInfo,\n        hasUnreadMessages: this.props.hasUnreadMessages\n      })));\n      return __jsx(React.Fragment, null);\n    });\n\n    this.state = {\n      streams: [],\n      streamInfo: [],\n      localStream: null,\n      localScreen: null,\n      audioMuted: false,\n      videoMuted: false,\n      mode: modes.GALLERY,\n      pinned: false,\n      localStreamError: null\n    };\n  }\n\n}\n\nexport default Conference;","map":null,"metadata":{},"sourceType":"module"}